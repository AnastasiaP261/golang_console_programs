### В данном репозитории будут собраны некоторые наиболее интересные небольшие консольные программки с курса по Go с платформы Stepik

Так как большая часть программ представлена кусочно в виде функций, git не дает их загрузить в виде файлов, поэтому они будут приведены только в тексте ниже вместе с формулировкой заданий.

## Задание 1:
> Внутри функции main (объявлять функцию не нужно) необходимо написать программу:
>
> На стандартный ввод подается 10 целых чисел, разделенных пробелами (числа могут повторяться). Для чтения из стандартного ввода импортирован пакет fmt.
>
> Вам необходимо вычислить результат выполнения функции work для каждого из полученных чисел. Функция work имеет следующий вид:  
> `func work(x int) int`  
>Результаты вычислений , разделенные пробелами, должны быть напечатаны в строку.
> 
> Однако работа функции work занимает слишком много времени. Выделенного вам времени выполнения не хватит на последовательную обработку каждого числа, поэтому необходимо реализовать кэширование уже готовых результатов и использовать их в работе.
> 
> После завершения работы программы результат выполнения будет дополнен информацией о соблюдении установленного лимита времени выполнения.


``` go
nums := make(map[int]int)
keys := make([]int, 0, 10)
i := 0
j := 0

for fmt.Scan(&i); j < 10; fmt.Scan(&i) {
j++
keys = append(keys, i)
}

for _, key := range keys {
if _, inMap := nums[key]; !inMap {
nums[key] = work(key)
}
fmt.Print(nums[key], " ")
}
```

### Задание 2

> Представьте что вы работаете в большой компании где используется модульная архитектура. Ваш коллега написал модуль с какой-то логикой (вы не знаете) и передает в вашу программу какие-то данные. Вы же пишете функцию которая считывает две переменных типа string ,  а возвращает число типа int64 которое нужно получить сложением этих строк.
>
>Но не было бы так все просто, ведь ваш коллега не пишет на Go, и он зол из-за того, что гоферам платят больше. Поэтому он решил подшутить над вами и подсунул вам подвох. Он придумал вставлять мусор в строки перед тем как вызывать вашу функцию.
>
>Поэтому предварительно вам нужно убрать из них мусор и конвертировать в числа. Под мусором имеются ввиду лишние символы и спец знаки. Разрешается использовать только определенные пакеты: fmt, strconv, unicode, strings,  bytes. Они уже импортированы, вам ничего импортировать не нужно!
>
>Считывать и выводить ничего не нужно!
>
>Ваша функция должна называться adding() !
>
>Считайте что функция и пакет main уже объявлены!

``` go
func adding(a, b string) int64 {
    s1 := clear(a)
    s2 := clear(b)
    
    n1, _ := strconv.Atoi(s1)
    n2, _ := strconv.Atoi(s2)
    
    return int64(n1 + n2)
}

func clear(str string) string {
    res := make([]rune, 0)
    
    for _, r := range str {
        if unicode.IsDigit(r) {
            res = append(res, r)
        }
    }
    
    return string(res)
}
```

### Задание 3

>Для решения данной задачи вам понадобится пакет strconv, возможно использовать пакеты strings или encoding/csv, или даже bufio - вы не ограничены в выборе способа решения задачи. В решениях мы поделимся своими способами решения этой задачи, предлагаем вам сделать то же самое.
>
>В привычных нам редакторах электронных таблиц присутствует удобное представление числа с разделителем разрядов в виде пробела, кроме того в России целая часть от дробной отделяется запятой. Набор таких чисел был экспортирован в формат CSV, где в качестве разделителя используется символ ";".
>
>На стандартный ввод вы получаете 2 таких вещественных числа, в качестве результата требуется вывести частное от деления первого числа на второе с точностью до четырех знаков после "запятой" (на самом деле после точки, результат не требуется приводить к исходному формату).

``` go
package main

import (
	"bufio"
	"os"
	"fmt"
	"strings"
	"strconv"
)

func main() {
	str, _ := bufio.NewReader(os.Stdin).ReadString('\n')
	str = strings.Trim(str, "\n")

	nums := strings.Split(str, ";")
	for i := range nums {
		nums[i] = strings.Replace(nums[i], ",", ".", -1)
		nums[i] = strings.Replace(nums[i], " ", "", -1)
	}

	n1, _ := strconv.ParseFloat(nums[0], 64)
	n2, _ := strconv.ParseFloat(nums[1], 64)

	fmt.Printf("%.4f", n1/n2)
}
```

### Задание 4

>Пришло время для задач, где вы сможете применить полученные знания на практике.
>
>Обязательные условия выполнения: данные со стандартного ввода читаются функцией readTask(), которая возвращает 3 значения типа пустой интерфейс. Эта функция использует пакеты encoding/json, fmt, и os - не удаляйте их из импорта. Скорее всего, вам понадобится пакет "fmt", но вы можете использовать любой другой пакет для записи в стандартный вывод не удаляя fmt.
>
>Итак, вы получаете 3 значения типа пустой интерфейс: если все удачно, то первые 2 значения будут float64. Третье значение в идеальном случае будет строкой, которая может иметь значения: "+", "-", "*", "/" (определенная математическая операция). Но такие идеальные случаи будут не всегда, вы можете получить значения других типов, а также строка в третьем значении может не относится к одной из указанных математических операций.
>
>Результат выполнения программы должен быть таков:
>
> 1) в штатной ситуации вы должны напечатать в стандартный вывод результат выполнения математической операции с точностью до 4 цифры после запятой (fmt.Printf(%.4f));
> 2) если первое или второе значение не является типом float64, вы должны напечатать сообщение об ошибке вида: value=полученное_значение: тип_значения (например: value=true: bool)
> 3) если третье значение имеет неверный тип или передан знак, не относящийся к указанным выше математическим операциям, сообщение об ошибке должно иметь вид: неизвестная операция  
> 
>Гарантируется, что ошибка в аргументах может быть только одна, поэтому если вы при проверке первого значения увидели, что оно содержит ошибку - печатайте сообщение об ошибке и завершайте работу программы, проверка остальных аргументов значения уже не имеет, а проверяющая система воспримет 2 сообщения об ошибке как нарушение условия выполнения задания.
>
>Удачи!

``` go
package main

import (
	"encoding/json" // пакет используется для проверки ответа, не удаляйте его
	"fmt"           // пакет используется для проверки ответа, не удаляйте его
	"os"            // пакет используется для проверки ответа, не удаляйте его
)

func printError(value interface{}) {
    fmt.Printf("value=%v: %T", value, value)

}

func main() {
	value1, value2, operation := readTask() // исходные данные получаются с помощью этой функции
                                            // все полученные значения имеют тип пустого интерфейса
    var v1, v2 float64
 
    switch value1.(type) {
        case float64:
            v1 = value1.(float64)
        default:
            printError(value1)
            return
    }
    
    switch value2.(type) {
        case float64:
            v2 = value2.(float64)
        default:
            printError(value2)
            return
    }
    
    switch operation.(type) {
        case string:
            switch operation.(string) {
                case "+":
                    fmt.Printf("%.4f", v1+v2)
                    return
                case "-":
                    fmt.Printf("%.4f", v1-v2)
                    return
                case "*":
                    fmt.Printf("%.4f", v1*v2)
                    return
                case "/":
                    fmt.Printf("%.4f", v1/v2)
                    return
                default:
                    fmt.Print("неизвестная операция")
                    return
            }
        default:
            fmt.Print("неизвестная операция")
            return
    }
}
```

### Задание 5

> Давайте используем ваши знания структур, методов и интерфейсов на практике и реализуем объект, удовлетворяющий интерфейсу fmt.Stringer. Назовем его "Батарейка".
>
>Во-первых, вы должны объявить новый тип, удовлетворяющий интерфейсу fmt.Stringer.
>
>Ваш тип должен предусматривать, что на печати он будет выглядеть так: <pre>[      XXXX]</pre> где пробелы - "опустошенная" емкость батареи, а X - "заряженная".
>
>Во-вторых, на стандартный ввод вы получаете строку, состоящую ровно из 10 цифр: 0 или 1 (порядок 0/1 случайный). Ваша задача считать эту строку любым возможным способом и создать на основе этой строки объект объявленного вами на первом этапе типа: надеюсь, вы понимаете, что строка символизирует емкость батарейки: 0 - это "опустошенная" часть, а 1 - "заряженная".
>
>В-третьих, созданный вами объект должен называться batteryForTest (использование этого имени обязательно).
>
>В вашем распоряжении фактически весь файл, НО завершающая фигурная скобка функции main() вам не видна, но она присутствует. Перед этой скобкой присутствует функция (которая вам тоже не видна), принимающая в качестве аргумента объект типа fmt.Stringer - batteryForTest, и направляющая его на стандартный вывод, поэтому вам не требуется выводить что-то на печать самостоятельно.
>
>Удачи!


``` go
package main

import (
    "fmt" // пакет используется для проверки ответа, не удаляйте его
    "strings"
)

type Battery struct {
    view string
}

func (b Battery) String() string {
    n0, n1 := 0, 0
    
    for _, ch := range b.view {
        if ch == '1' {
            n1++
        } else if ch == '0' {
            n0++
        }
    }
    
    res := "[" + strings.Repeat(" ", n0) + strings.Repeat("X", n1) + "]"
    return res
}

func main() {
    var str string
    fmt.Scan(&str)
    
    batteryForTest := Battery{view: str}
  
// } Скобка, закрывающая функцию main() вам не видна, но она есть
```

### Задание 6

> Напишите элемент конвейера (функцию), что запоминает предыдущее значение и отправляет значения на следующий этап конвейера только если оно отличается от того, что пришло ранее.
>
>Ваша функция должна принимать два канала - inputStream и outputStream, в первый вы будете получать строки, во второй вы должны отправлять значения без повторов. В итоге в outputStream должны остаться значения, которые не повторяются подряд. Не забудьте закрыть канал ;)

``` go
package main

import (
	"fmt"
)

func removeDuplicates(in chan string, out chan string) {
	var prev_d string

	for d := range in {
		if d != prev_d {
			out <- d
			prev_d = d
		}
	}
	close(out)
}

func main() {
	inputStream := make(chan string)
	outputStream := make(chan string)
	go removeDuplicates(inputStream, outputStream)

	go func() {
		defer close(inputStream)

		for _, r := range "112334456" {
			inputStream <- string(r)
		}
	}()

	for x := range outputStream {
		fmt.Print(x)
	}
}
```


<!--
### Задание 7

>
>
> 

``` go

```
/-->



