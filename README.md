### В данном репозитории будут собраны некоторые наиболее интересные небольшие консольные программки с курса по Go с платформы Stepik

Так как большая часть программ представлена кусочно в виде функций, git не дает их загрузить в виде файлов, поэтому они
будут приведены только в тексте ниже вместе с формулировкой заданий.

## Задание 1:

> Внутри функции main (объявлять функцию не нужно) необходимо написать программу:
>
> На стандартный ввод подается 10 целых чисел, разделенных пробелами (числа могут повторяться). Для чтения из стандартного ввода импортирован пакет fmt.
>
> Вам необходимо вычислить результат выполнения функции work для каждого из полученных чисел. Функция work имеет следующий вид:  
> `func work(x int) int`  
> Результаты вычислений , разделенные пробелами, должны быть напечатаны в строку.
>
> Однако работа функции work занимает слишком много времени. Выделенного вам времени выполнения не хватит на последовательную обработку каждого числа, поэтому необходимо реализовать кэширование уже готовых результатов и использовать их в работе.
>
> После завершения работы программы результат выполнения будет дополнен информацией о соблюдении установленного лимита времени выполнения.

``` go
nums := make(map[int]int)
keys := make([]int, 0, 10)
i := 0
j := 0

for fmt.Scan(&i); j < 10; fmt.Scan(&i) {
j++
keys = append(keys, i)
}

for _, key := range keys {
if _, inMap := nums[key]; !inMap {
nums[key] = work(key)
}
fmt.Print(nums[key], " ")
}
```

### Задание 2

> Представьте что вы работаете в большой компании где используется модульная архитектура. Ваш коллега написал модуль с какой-то логикой (вы не знаете) и передает в вашу программу какие-то данные. Вы же пишете функцию которая считывает две переменных типа string , а возвращает число типа int64 которое нужно получить сложением этих строк.
>
>Но не было бы так все просто, ведь ваш коллега не пишет на Go, и он зол из-за того, что гоферам платят больше. Поэтому он решил подшутить над вами и подсунул вам подвох. Он придумал вставлять мусор в строки перед тем как вызывать вашу функцию.
>
>Поэтому предварительно вам нужно убрать из них мусор и конвертировать в числа. Под мусором имеются ввиду лишние символы и спец знаки. Разрешается использовать только определенные пакеты: fmt, strconv, unicode, strings, bytes. Они уже импортированы, вам ничего импортировать не нужно!
>
>Считывать и выводить ничего не нужно!
>
>Ваша функция должна называться adding() !
>
>Считайте что функция и пакет main уже объявлены!

``` go
func adding(a, b string) int64 {
    s1 := clear(a)
    s2 := clear(b)
    
    n1, _ := strconv.Atoi(s1)
    n2, _ := strconv.Atoi(s2)
    
    return int64(n1 + n2)
}

func clear(str string) string {
    res := make([]rune, 0)
    
    for _, r := range str {
        if unicode.IsDigit(r) {
            res = append(res, r)
        }
    }
    
    return string(res)
}
```

### Задание 3

> Для решения данной задачи вам понадобится пакет strconv, возможно использовать пакеты strings или encoding/csv, или даже bufio - вы не ограничены в выборе способа решения задачи. В решениях мы поделимся своими способами решения этой задачи, предлагаем вам сделать то же самое.
>
>В привычных нам редакторах электронных таблиц присутствует удобное представление числа с разделителем разрядов в виде пробела, кроме того в России целая часть от дробной отделяется запятой. Набор таких чисел был экспортирован в формат CSV, где в качестве разделителя используется символ ";".
>
>На стандартный ввод вы получаете 2 таких вещественных числа, в качестве результата требуется вывести частное от деления первого числа на второе с точностью до четырех знаков после "запятой" (на самом деле после точки, результат не требуется приводить к исходному формату).

``` go
package main

import (
	"bufio"
	"os"
	"fmt"
	"strings"
	"strconv"
)

func main() {
	str, _ := bufio.NewReader(os.Stdin).ReadString('\n')
	str = strings.Trim(str, "\n")

	nums := strings.Split(str, ";")
	for i := range nums {
		nums[i] = strings.Replace(nums[i], ",", ".", -1)
		nums[i] = strings.Replace(nums[i], " ", "", -1)
	}

	n1, _ := strconv.ParseFloat(nums[0], 64)
	n2, _ := strconv.ParseFloat(nums[1], 64)

	fmt.Printf("%.4f", n1/n2)
}
```

### Задание 4

> Пришло время для задач, где вы сможете применить полученные знания на практике.
>
>Обязательные условия выполнения: данные со стандартного ввода читаются функцией readTask(), которая возвращает 3 значения типа пустой интерфейс. Эта функция использует пакеты encoding/json, fmt, и os - не удаляйте их из импорта. Скорее всего, вам понадобится пакет "fmt", но вы можете использовать любой другой пакет для записи в стандартный вывод не удаляя fmt.
>
>Итак, вы получаете 3 значения типа пустой интерфейс: если все удачно, то первые 2 значения будут float64. Третье значение в идеальном случае будет строкой, которая может иметь значения: "+", "-", "*", "/" (определенная математическая операция). Но такие идеальные случаи будут не всегда, вы можете получить значения других типов, а также строка в третьем значении может не относится к одной из указанных математических операций.
>
>Результат выполнения программы должен быть таков:
>
> 1) в штатной ситуации вы должны напечатать в стандартный вывод результат выполнения математической операции с точностью до 4 цифры после запятой (fmt.Printf(%.4f));
> 2) если первое или второе значение не является типом float64, вы должны напечатать сообщение об ошибке вида: value=полученное_значение: тип_значения (например: value=true: bool)
> 3) если третье значение имеет неверный тип или передан знак, не относящийся к указанным выше математическим операциям, сообщение об ошибке должно иметь вид: неизвестная операция
>
>Гарантируется, что ошибка в аргументах может быть только одна, поэтому если вы при проверке первого значения увидели, что оно содержит ошибку - печатайте сообщение об ошибке и завершайте работу программы, проверка остальных аргументов значения уже не имеет, а проверяющая система воспримет 2 сообщения об ошибке как нарушение условия выполнения задания.
>
>Удачи!

``` go
package main

import (
	"encoding/json" // пакет используется для проверки ответа, не удаляйте его
	"fmt"           // пакет используется для проверки ответа, не удаляйте его
	"os"            // пакет используется для проверки ответа, не удаляйте его
)

func printError(value interface{}) {
    fmt.Printf("value=%v: %T", value, value)

}

func main() {
	value1, value2, operation := readTask() // исходные данные получаются с помощью этой функции
                                            // все полученные значения имеют тип пустого интерфейса
    var v1, v2 float64
 
    switch value1.(type) {
        case float64:
            v1 = value1.(float64)
        default:
            printError(value1)
            return
    }
    
    switch value2.(type) {
        case float64:
            v2 = value2.(float64)
        default:
            printError(value2)
            return
    }
    
    switch operation.(type) {
        case string:
            switch operation.(string) {
                case "+":
                    fmt.Printf("%.4f", v1+v2)
                    return
                case "-":
                    fmt.Printf("%.4f", v1-v2)
                    return
                case "*":
                    fmt.Printf("%.4f", v1*v2)
                    return
                case "/":
                    fmt.Printf("%.4f", v1/v2)
                    return
                default:
                    fmt.Print("неизвестная операция")
                    return
            }
        default:
            fmt.Print("неизвестная операция")
            return
    }
}
```

### Задание 5

> Давайте используем ваши знания структур, методов и интерфейсов на практике и реализуем объект, удовлетворяющий интерфейсу fmt.Stringer. Назовем его "Батарейка".
>
>Во-первых, вы должны объявить новый тип, удовлетворяющий интерфейсу fmt.Stringer.
>
>Ваш тип должен предусматривать, что на печати он будет выглядеть так: <pre>[      XXXX]</pre> где пробелы - "опустошенная" емкость батареи, а X - "заряженная".
>
>Во-вторых, на стандартный ввод вы получаете строку, состоящую ровно из 10 цифр: 0 или 1 (порядок 0/1 случайный). Ваша задача считать эту строку любым возможным способом и создать на основе этой строки объект объявленного вами на первом этапе типа: надеюсь, вы понимаете, что строка символизирует емкость батарейки: 0 - это "опустошенная" часть, а 1 - "заряженная".
>
>В-третьих, созданный вами объект должен называться batteryForTest (использование этого имени обязательно).
>
>В вашем распоряжении фактически весь файл, НО завершающая фигурная скобка функции main() вам не видна, но она присутствует. Перед этой скобкой присутствует функция (которая вам тоже не видна), принимающая в качестве аргумента объект типа fmt.Stringer - batteryForTest, и направляющая его на стандартный вывод, поэтому вам не требуется выводить что-то на печать самостоятельно.
>
>Удачи!

``` go
package main

import (
    "fmt" // пакет используется для проверки ответа, не удаляйте его
    "strings"
)

type Battery struct {
    view string
}

func (b Battery) String() string {
    n0, n1 := 0, 0
    
    for _, ch := range b.view {
        if ch == '1' {
            n1++
        } else if ch == '0' {
            n0++
        }
    }
    
    res := "[" + strings.Repeat(" ", n0) + strings.Repeat("X", n1) + "]"
    return res
}

func main() {
    var str string
    fmt.Scan(&str)
    
    batteryForTest := Battery{view: str}
  
// } Скобка, закрывающая функцию main() вам не видна, но она есть
```

### Задание 6

> Напишите элемент конвейера (функцию), что запоминает предыдущее значение и отправляет значения на следующий этап конвейера только если оно отличается от того, что пришло ранее.
>
>Ваша функция должна принимать два канала - inputStream и outputStream, в первый вы будете получать строки, во второй вы должны отправлять значения без повторов. В итоге в outputStream должны остаться значения, которые не повторяются подряд. Не забудьте закрыть канал ;)

``` go
package main

import (
	"fmt"
)

func removeDuplicates(in chan string, out chan string) {
	var prev_d string

	for d := range in {
		if d != prev_d {
			out <- d
			prev_d = d
		}
	}
	close(out)
}

func main() {
	inputStream := make(chan string)
	outputStream := make(chan string)
	go removeDuplicates(inputStream, outputStream)

	go func() {
		defer close(inputStream)

		for _, r := range "112334456" {
			inputStream <- string(r)
		}
	}()

	for x := range outputStream {
		fmt.Print(x)
	}
}
```

### Задание 8

> Внутри функции main (функцию объявлять не нужно), вам необходимо в отдельных горутинах вызвать функцию work() 10 раз и дождаться результатов выполнения вызванных функций. Функция work() ничего не принимает и не возвращает. Пакет "sync" уже импортирован.

``` go
// вы уже внутри main()
wg := new(sync.WaitGroup)
for i:=0; i<10; i++ {
    wg.Add(1)
    go func (wg *sync.WaitGroup) {
        defer wg.Done()
        work()
    } (wg)
}

wg.Wait()
```

### Задание 9

> Вам необходимо написать функцию calculator следующего вида:
>
>`func calculator(firstChan <-chan int, secondChan <-chan int, stopChan <-chan struct{}) <-chan int`  
> Функция получает в качестве аргументов 3 канала, и возвращает канал типа <-chan int.
>
> - в случае, если аргумент будет получен из канала firstChan, в выходной (возвращенный) канал вы должны отправить квадрат аргумента.
> - в случае, если аргумент будет получен из канала secondChan, в выходной (возвращенный) канал вы должны отправить результат умножения аргумента на 3.
> - в случае, если аргумент будет получен из канала stopChan, нужно просто завершить работу функции.
> - Функция calculator должна быть неблокирующей, сразу возвращая управление. Ваша функция получит всего одно значение в один из каналов - получили значение, обработали его, завершили работу.
>
> После завершения работы необходимо освободить ресурсы, закрыв выходной канал, если вы этого не сделаете, то превысите предельное время работы.

``` go
func calculator(firstChan <-chan int, secondChan <-chan int, stopChan <-chan struct{}) <-chan int {
    ch := make(chan int)
    
    go func (){
        for {
            select {
                case num := <- firstChan:
                ch <- num*num
                close(ch)
                return
				
                case num := <- secondChan:
                ch <- num*3
                close(ch)
                return
				
                case <-stopChan:
                close(ch)
                return
            }
        }
    } ()
    
    return ch
}
```

### Задание 10

> Вам необходимо написать функцию calculator следующего вида:  
> `func calculator(arguments <-chan int, done <-chan struct{}) <-chan int`  
> В качестве аргумента эта функция получает два канала только для чтения, возвращает канал только для чтения.
>
>Через канал arguments функция получит ряд чисел, а через канал done - сигнал о необходимости завершить работу. Когда сигнал о завершении работы будет получен, функция должна в выходной (возвращенный) канал отправить сумму полученных чисел.
>
>Функция calculator должна быть неблокирующей, сразу возвращая управление.
>
>Выходной канал должен быть закрыт после выполнения всех оговоренных условий, если вы этого не сделаете, то превысите предельное время работы.

``` go
func calculator(arguments <-chan int, done <-chan struct{}) <-chan int {
    ch := make(chan int)
    sum := 0
    
    go func (){
        for {
            select {
                case num := <- arguments:
                sum += num
                
                case <-done:
                ch <- sum
                close(ch)
                return
            }
        }
    } ()
    
    return ch
}
```

### Задание 11

>Данная задача в основном ориентирована на изучение типа bufio.Reader, поскольку этот тип позволяет считывать данные постепенно.
>
>В тестовом файле, который вы можете скачать из нашего [репозитория](https://github.com/semyon-dev/stepik-go/tree/master/work_with_files/task_sep_1) на github.com, содержится длинный ряд чисел, разделенных символом ";". Требуется найти, на какой позиции находится число 0 и указать её в качестве ответа. Требуется вывести именно позицию числа, а не индекс (то-есть порядковый номер, нумерация с 1).
>
>Например:  12;234;6;0;78 :
>Правильный ответ будет порядковый номер числа: 4

``` go
package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strings"
)

func readCsvFile(filePath string) []string {
	f, err := os.Open(filePath)
	if err != nil {
		log.Fatal("Unable to read input file "+filePath, err)
	}
	defer f.Close()

	csvReader := csv.NewReader(f)
	records, err := csvReader.ReadAll()
	if err != nil {
		log.Fatal("Unable to parse file as CSV for "+filePath, err)
	}

	arrayStrings := strings.Split(records[0][0], ";")

	return arrayStrings
}

func searchNull(data []string) int {
	for i, el := range data {
		if el == "0"{
			return i+1
		}
	}
	return -1
}


func main() {
	records := readCsvFile("F:\\загрузки\\text.txt")
	fmt.Println(searchNull(records))
}
```


### Задание 12

>Данная задача ориентирована на реальную работу с данными в формате JSON. Для решения мы будем использовать справочник ОКВЭД (Общероссийский классификатор видов экономической деятельности), который был размещен на web-портале data.gov.ru.
>
>Необходимая вам информация о структуре данных содержится в файле structure-20190514T0000.json, а сами данные, которые вам потребуется декодировать, содержатся в файле data-20190514T0100.json. Файлы размещены в нашем [репозитории](https://github.com/semyon-dev/stepik-go/tree/master/work_with_json) на github.com.
>
>Для того, чтобы показать, что вы действительно смогли декодировать документ вам необходимо в качестве ответа записать сумму полей global_id всех элементов, закодированных в файле.


``` go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
)

type YouStruct struct {
	Id int `json:"global_id"`
}

func readTextFile(filePath string) int {
	f, err := os.Open(filePath)
	if err != nil {
		log.Fatal("Unable to read input file "+filePath, err)
	}
	defer f.Close()

	dec := json.NewDecoder(f)
	dst := []YouStruct{}
	dec.Decode(&dst)

	sum := 0
	for _, el := range dst {
		sum += el.Id
	}

	return sum
}

func main() {
	fmt.Println(readTextFile("F:\\загрузки\\text.txt"))
}
```

### Задание 13

> На стандартный ввод подаются данные о студентах университетской группы в формате JSON:
>
> ``` json
> {
>   "ID":134,
>   "Number":"ИЛМ-1274",
>   "Year":2,
>   "Students":[
>       {
>           "LastName":"Вещий",
>           "FirstName":"Лифон",
>           "MiddleName":"Вениаминович",
>           "Birthday":"4апреля1970года",
>           "Address":"632432,г.Тобольск,ул.Киевская,дом6,квартира23",
>           "Phone":"+7(948)709-47-24",
>           "Rating":[1,2,3]
>       },
>       {
>           ...
>       }
>   ]
>}
>```
>В сведениях о каждом студенте содержится информация о полученных им оценках (Rating). Требуется прочитать данные, и рассчитать среднее количество оценок, полученное студентами группы. Ответ на задачу требуется записать на стандартный вывод в формате JSON в следующей форме:
>
>``` json
>{
>   "Average": 14.1
>}
>```
>Как вы понимаете, для декодирования используется функция Unmarshal, а для кодирования MarshalIndent (префикс - пустая строка, отступ - 4 пробела).

``` go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
)

type myStruct struct {
	Students []struct {
		Rating []float64 `json:"Rating"`
	} `json:"Students"`
}

func main() {
	sum := 0.0
	num_students := 0.0
	all_data := myStruct{}

	data, err := ioutil.ReadAll(os.Stdin)
	if err == nil {
		if err := json.Unmarshal([]byte(data), &all_data); err == nil {
			num_students = float64(len(all_data.Students))
			for _, el := range all_data.Students{
				sum += float64(len(el.Rating))
			}
		}
	}

	res_data := map[string]float64 {"Average": sum / num_students}

	answer, err := json.MarshalIndent(res_data, "", "    ")
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Printf("%s", answer)
}
```

<!--
### Задание 7

>
>
> 

``` go

```
/-->



